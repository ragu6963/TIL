# 5장 오차역전파법

`오차역전파법`은 가중치 매개변수의 기울기를 효율적으로 계산하는 방법이다.

## 5.1 계산 그래프

`계산그래프`는 계산 과정을 그래프로 나타낸 것이다. 여기서 `그래프`는 자료구조의 그래프로 복수의`노드`와 `에지`로 표현된다.

### 5.1.1. 계산 그래프로 풀다

계산 그래프가 어떤 것인지 알기 위해 간단한 문제를 풀어보자

> 문제 1 : 현빈 군은 슈퍼에서 1개에 100원인 사과를 2개 샀습니다. 이때 지불 금액을 구하세요. 단, 소비세가 10% 부과됩니다.

> 문제1의 계산그래프

<img src="5장_오차역전파법.assets/fig 5-1.png">

> 사과의 개수와 소비세를 변수 취급한 계산그래프

<img src="5장_오차역전파법.assets/fig 5-2.png">

> 문제 2 : 현빈 군은 슈퍼엣 ㅓ사과를 2개, 귤을 3개 샀습니다. 사과는 1개에 100원, 귤을 1개 150원입니다. 소비세가 10%일 때 지불 금액을 구하세요.

> 문제2의 계산그래프

<img src="5장_오차역전파법.assets/fig 5-3.png">

`계산그래프`를 이용한 문제풀이의 흐름

1. 계산그래프를 구성한다.
2. 그래프에서 계산을 왼쪽에서 오른쪽으로 진행한다.

여기서 `계산을 왼쪽에서 오른쪽으로 진행`하는 단계를 `순전파`라고 한다. 그리고 반대 방향의 흐름을 `역전파`라고 한다.

### 5.1.2 국소적 계산

계산그래프의 특징은 `국소적 계산`을 전파함으로써 최종 결과를 얻는다는 점이다. 국소적이란 `자신과 직접 관계된 작은 범위`라는 뜻이다.

예를들어 사과 2개를 포함한 여러 식품을 구입하는 경우를 보자.

<img src="5장_오차역전파법.assets/fig 5-4.png">

여기서 핵심은 각 `노드`에서의 계산은 국소적 계산이라는 점이다. 사과와 그 외의 물풀 값을 더하는 계산에서 4000은 어떻게 계산되었는지는 상관없이 단지 두 숫자`4000,200`을 더하면 된다는 뜻이다.

이처럼 계산그래프는 `국소적 계산`에 집중함으로써 전체의 복잡한 계산을 해낼 수 있다.

### 5.1.3 왜 계산 그래프로 푸는가?

> 계산그래프의 이점

1. `국소적 계산` : 아무리 복잡해도 각 노드에서는 단순한 계산에 집중해서 문제를 단순화 할 수 있다.
2. 중간 계산 결과를 모두 보관할 수 있다.
3. 역전파를 통해 `미분`를 효율적으로 계산할 수 있다.

가령 문제1에서 사과 가교ㅕㄱ이 오르면 최종 금액에 어떤 영향을 끼치는지를 알고 싶다는 것은 `사과 가격에 대한 지불 금액의 미분`을 구하는 것과 동일하다.

<img src="5장_오차역전파법.assets/fig 5-5.png">

## 5.2 연쇄법칙

`역전파`는 `국소적인 미분`을 순방향과는 반대로 전달한다. 또한, `국소적 미분`을 전달하는 원리는 `연쇄법칙`에 따른다.

### 5.2.1 계산 그래프의 역전파

> 역전파의 예시 그림

<img src="5장_오차역전파법.assets/fig 5-6.png">

위 그림에서 역전파의 계산 절차는 신호 E에 노드의 국소적미분을 곱한 후 다음 노드로 전달하는 것이다.

여기서 국소적 미분은 x`입력`에 대한 y`출력`의 미분을 뜻한다. 그리고 이 국소적 미분을 사류에서 전달된 값`E`에 곱해 앞쪽 노드로 전달한다.

`입력의 변화에 따라 출력이 어떻게 변화하나? -> 기울기(미분)`

### 5.2.2 연쇄법칙?

연쇄법칙을 설명하기 위해서는 합성함수의 이해가 필요하다. `합성함수`란 여러 함수로 구성된 함수이다.

예를 들어 z = (x+y)^2는 

<img src="5장_오차역전파법.assets/e 5.1.png">

로 표현가능하다.

연쇄법칙은 합성 함수의 미분에 대한 성질이며

> 합성 함수의 미분은 합성 함수를 구성하는 각 함수의 미분의 곱으로 나타낼 수 있다.

로 정의 된다.

### 5.2.3 연쇄법칙과 계산 그래프



## 5.3 역전파

### 5.3.1 덧셈 노드의 역전파

> z = x + y 의 미분의 해석과 계산 그래프

<img src="5장_오차역전파법.assets/e 5.5.png">

<img src="5장_오차역전파법.assets/fig 5-9.png">

그림과 같이 역전파 때는 상류에서 전해진 미분에 1을 곱하여 하류로 흘린다. 즉, `덧셈 노드`의 역전파는 1을 곱하기만 할 뿐이고, 입력된 값을 그대로 다음 노드로 보낸다.

### 5.3.2 곱셈 노드의 역전파

> z = xy 의 미분의 해석과 계산 그래프

<img src="5장_오차역전파법.assets/e 5.6.png">

<img src="5장_오차역전파법.assets/fig 5-12.png">

`곱셈 노드`역전파는 상류의 값에 순전파 때의 입력신호들을 `서로 바꾼 값`을 곱해서 하류로 보낸다.

### 5.3.3 사과 쇼핑의 예

<img src="5장_오차역전파법.assets/fig 5-14.png">

## 5.4 단순한 계층 구현하기

### 5.4.1 곱셈계층

```python
class MulLayer:
    def __init__(self):
        # x, y 초기화
        self.x = None
        self.y = None

    # 순전파
    def forward(self, x, y):
        self.x = x
        self.y = y
        out = x * y
        return out

    # 역전파
    def backward(self, dout):
        # 출력의 미분에 x와 y를 서로 교차해서 곱하기
        dx = dout * self.y
        dy = dout * self.x
        return dx, dy


if __name__ == "__main__":
    apple = 100
    apple_num = 2
    tax = 1.1

    # 계층 생성
    mul_apple_layer = MulLayer()
    mul_tax_layer = MulLayer()

    # 순전판
    apple_price = mul_apple_layer.forward(apple, apple_num)
    price = mul_tax_layer.forward(apple_price, tax)
    print(price)

    # 역전파
    dprice = 1
    # 순전파의 반대 반향
    dapple_price, dtax = mul_tax_layer.backward(dprice)
    dapple, dapple_num = mul_apple_layer.backward(dapple_price)
    print(dapple, dapple_num, dtax)

```

### 5.4.2 덧셈계층

```python
class AddLayer:
    def __init__(self):
        pass

    # 순전파
    def forward(self, x, y):
        out = x + y
        return out

    # 역전파
    def backward(self, dout):
        # 출력의 미분에 1을 곱하기
        dx = dout * 1
        dy = dout * 1
        return dx, dy
```

<img src="5장_오차역전파법.assets/fig 5-17.png">

> 위 계산 그래프 코드 순전파 역전파 구현

```python
class AddLayer:
    def __init__(self):
        pass

    # 순전파
    def forward(self, x, y):
        out = x + y
        return out

    # 역전파
    def backward(self, dout):
        # 출력의 미분에 1을 곱하기
        dx = dout * 1
        dy = dout * 1
        return dx, dy


class MulLayer:
    def __init__(self):
        self.x = None
        self.y = None

    def forward(self, x, y):
        self.x = x
        self.y = y
        out = x * y
        return out

    def backward(self, dout):
        dx = dout * self.y
        dy = dout * self.x
        return dx, dy


if __name__ == "__main__":
    apple = 100
    apple_num = 2
    orange = 150
    orange_num = 3
    tax = 1.1

    # 계층 생성
    mul_apple_layer = MulLayer()
    mul_orange_layer = MulLayer()
    add_apple_orange_layer = AddLayer()
    mul_price_layer = MulLayer()

    # 순전판
    # 사과 가격 계산
    apple_price = mul_apple_layer.forward(apple, apple_num)
    # 귤 가격 계산
    orange_price = mul_orange_layer.forward(orange, orange_num)
    # 사과 + 귤 계산
    add_price = add_apple_orange_layer.forward(apple_price, orange_price)
    mul_price = mul_price_layer.forward(add_price, tax)

    print(mul_price) # 715.0000000000001

    # 역전파
    dprice = 1
    # 순전파의 반대 순서
    add_dprice, dtax = mul_price_layer.backward(dprice)
    apple_dprice, orange_dprice = add_apple_orange_layer.backward(add_dprice)
    dorange, orange_dnum = mul_orange_layer.backward(orange_dprice)
    dapple, apple_dnum = mul_apple_layer.backward(apple_dprice)

    print(add_dprice, dtax, apple_dprice, orange_dprice) # 1.1 650 1.1 1.1
    print(dorange, orange_dnum) # 3.3000000000000003 165.0
    print(dapple, apple_dnum) # 2.2 110.00000000000001
```

## 5.5 활성화 함수 계층 구현하기

### 5.5.1 ReLU 계층

> ReLU 함수 수식과 x에 대한 y의 미분

<img src="5장_오차역전파법.assets/e 5.7.png">

<img src="5장_오차역전파법.assets/e 5.8.png">

> ReLU 계산그래프

<img src="5장_오차역전파법.assets/fig 5-18.png">

```python
class ReLU:
    def __init__(self):
        self.mask = None

    def forward(self, x):
        # 입력 행렬에서 0 이하인 인덱스 True
        self.mask = x <= 0
        out = x.copy()
        # 입력 행렬에서 0 이하인 인덱스 값 0으로 초기화
        out[self.mask] = 0
        return out

    def backward(self, dout):
        # 순전파 때 만들어둔 mask를 사용해 상류에서 전파된 dout에서 0 이하 값 인덱스 0으로 초기화
        dout[self.mask] = 0
        dx = dout
        return dx

```

### 5.5.2 Sigmoid 계층

> 시그모이드 순전파와 역전파

<img src="5장_오차역전파법.assets/fig 5-19.png">

<img src="5장_오차역전파법.assets/fig 5-20.png">

`/`와 `exp` 연산이 처음 등장하였다.

일단, `exp`연산은 순전파와 역전파에서 동일하게 exp(x)을 반환해준다.

`/`연산은 순전파에서는 1/x 를 역전파에서는 상류에서 온 값에 `-y^2 `를 곱해서 반환해준다.



