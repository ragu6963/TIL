# [Gold V] 17070. 파이프 옮기기 1

### 풀이

처음에는  dfs로 풀려고 했는데 파이썬에는 dfs로 풀면 시간초과가 발생한다.

그래서 `dp`로 문제를 풀었다.

값을 입력받고, `[y,x,모양]`을 저장할 배열`graph`를 만든다.

파이프의 모양은 3가지로 `0 가로, 1 세로, 2 대각선`으로 표현한다.

파이프의 앞 부분은 `[0,1,0]`으로 시작한다.

기준에 따라 `이전 좌표의 값`을  더해서 `현재 좌표의 값`을 구한다.

먼저 첫 번째 열에서 가로로 이동가능한 공간을 모두 찾아서`좌표에 해당하는 값이 1이 아닌` 1로 초기화한다. 

나머지 구역에서 `y = 1 ,x = 2`부터 시작해 가로 세로 대각선으로 이동 가능한 경우를 찾는다.

`x = 2`부터 시작하는 이유는 가로모양에서는 가로 혹은 대각선으로만 이동가능하고, 파이프의 시작이 `x = 1`이기 때문에 다음 x는 무조건 2부터 가능하다.

> 대각선 이동 확인

현재 좌표`y,x` 기준 `(y,x),(y-1,x),(y,x-1)`의 값이 0이면 이전 좌표`y-1,x-1`에서 대각선으로 이동가능하다.

세 가지 모양에서 모두에서 대각선으로 이동가능하기 때문에 `y-1,x-1`에서의 세 가지 파이프 모양의 값을 더한다.

> 가로 세로 이동 확인

현재 좌표`y,x`의 값이 0 이면 이전 좌표에서 가로`y,x-1` 세로`y-1,x` 이동이 가능하다.

가로는 가로 대각선, 세로는 세로 대각선에도 이동가능하기 때문에 이전 좌표에서 해당하는 모양 두 가지의 값을 더한다.

> 정답 출력

마지막 좌표`N-1,N-1`의 가로`0` 세로`1` 대각선`2` 의 값을 더해서 답을 출력한다. 

### 코드

```python
# [Gold V] 17070. 파이프 옮기기 1
# https://www.acmicpc.net/problem/17070
import sys

sys.stdin = open("./input.txt", "r") 

N = int(input())

# 입력 맵
arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
graph = [[[0] * 3 for _ in range(N)] for _ in range(N)]

# 초기 위치, 모양 초기화
# 0 : 가로
# 1 : 세로
# 2 : 대각선
graph[0][1][0] = 1

# 첫번째 열 가로로 이동가능한 곳 값 초기화
for x in range(2, N):
	if arr[0][x] == 0:
		graph[0][x][0] = 1

for y in range(1, N):
	for x in range(2, N):
		# 대각선 이동 가능한 경우
		if arr[y][x] == arr[y - 1][x] == arr[y][x - 1] == 0:
			graph[y][x][2] = (graph[y - 1][x - 1][0] + graph[y - 1][x - 1][1] +
							  graph[y - 1][x - 1][2])
            
		if arr[y][x] == 0:
			# 가로 이동
			# 대각선 -> 가로 + 가로 -> 가로
			graph[y][x][0] = graph[y][x - 1][2] + graph[y][x - 1][0]

			# 세로 이동
			# 대각선 -> 세로 + 세로 -> 세로
			graph[y][x][1] = graph[y - 1][x][2] + graph[y - 1][x][1]
print(sum(graph[N-1][N-1]))

```

